#!/usr/bin/env bash
# agentenv — portable dev environments for agents and humans
# Dev shell in ~2s via APFS COW volume clones + persistent home environments
set -euo pipefail

VOLUMES_DIR="$HOME/Library/Application Support/com.apple.container/volumes"
GOLDEN_VOL="nix-golden"
ENV_VOL_PREFIX="agentenv-env-"
IMAGE="agentenv"
TEMP_VOL="agentenv-$$"
PROFILE_DIR="$HOME/config"
INSTALLED_DIR="$HOME/config/installed"
BIN_DIR="$HOME/config/bin"
SKILLS_DIR="$HOME/config/skills"
WRAPPER_HEADER="# managed by agentenv install — do not edit"
FORCE_TTY=false
ENV_NAME=""
CMD_ARGS=()

die() { echo "agentenv: $*" >&2; exit 1; }

usage() {
  cat <<EOF
Usage: agentenv [options] [directory] [-- command [args...]]
       agentenv env create <name> [directory]
       agentenv env list
       agentenv env rm <name>
       agentenv install [name]
       agentenv uninstall <name>
       agentenv list
       agentenv rewrap

Commands:
  env create <name> [dir]  Create environment from directory (copied into named volume)
  env list                 List environments
  env rm <name>            Delete an environment
  install [name]           Install cwd as a mutable repo (name defaults to basename)
  uninstall <name>         Remove an installed repo and its wrappers/skills
  list                     List installed repos
  rewrap                   Regenerate all host wrappers and skill links

Options:
  --env <name>            Use a persistent environment (named volume as HOME)
  -p, --profile <dir>    Override profile directory (default: ~/config)
  --no-profile            Launch without profile
  -t                      Force TTY allocation for non-interactive commands
  -h, --help              Show this help

Examples:
  agentenv --env work .             # dev shell with persistent environment
  agentenv .                        # dev shell with personal profile
  agentenv env create work ./my-env # create environment from directory
  agentenv env list                 # list environments
  agentenv env rm work              # delete environment
  agentenv . -- make test           # run command, exit with its status
  agentenv install                  # install cwd (name = basename)
  agentenv list                     # show installed repos
EOF
  exit 0
}

# --- Host wrapper management ---

is_managed_wrapper() {
  local file="$1"
  [ -f "$file" ] && head -2 "$file" | grep -qE "managed by (agentenv|config) install"
}

generate_wrappers() {
  local name="$1"
  local repo="$INSTALLED_DIR/$name"
  local target
  target=$(readlink -f "$repo" 2>/dev/null) || die "broken symlink: $name"

  [ -d "$target/bin" ] || return 0

  local has_flake=false
  [ -f "$target/flake.nix" ] && has_flake=true

  for bin_entry in "$target/bin"/*; do
    [ -f "$bin_entry" ] || [ -L "$bin_entry" ] || continue
    local cmd
    cmd=$(basename "$bin_entry")
    local wrapper="$BIN_DIR/$cmd"

    # Don't overwrite non-managed files
    if [ -f "$wrapper" ] && ! is_managed_wrapper "$wrapper"; then
      echo "agentenv: warning: $BIN_DIR/$cmd exists and is not managed — skipping"
      continue
    fi

    if $has_flake; then
      cat > "$wrapper" <<WRAP
#!/usr/bin/env sh
$WRAPPER_HEADER
exec nix develop $INSTALLED_DIR/$name --command $INSTALLED_DIR/$name/bin/$cmd "\$@"
WRAP
    else
      cat > "$wrapper" <<WRAP
#!/usr/bin/env sh
$WRAPPER_HEADER
exec $INSTALLED_DIR/$name/bin/$cmd "\$@"
WRAP
    fi
    chmod +x "$wrapper"
    echo "  $cmd"
  done
}

remove_wrappers() {
  local name="$1"
  local repo="$INSTALLED_DIR/$name"
  local target
  target=$(readlink -f "$repo" 2>/dev/null || echo "")

  if [ -n "$target" ] && [ -d "$target/bin" ]; then
    for bin_entry in "$target/bin"/*; do
      [ -f "$bin_entry" ] || [ -L "$bin_entry" ] || continue
      local cmd
      cmd=$(basename "$bin_entry")
      local wrapper="$BIN_DIR/$cmd"
      if is_managed_wrapper "$wrapper"; then
        rm "$wrapper"
        echo "  removed $cmd"
      fi
    done
  else
    # Broken symlink — scan all wrappers for references to this name
    for wrapper in "$BIN_DIR"/*; do
      [ -f "$wrapper" ] || continue
      if is_managed_wrapper "$wrapper" && grep -qF "$INSTALLED_DIR/$name/" "$wrapper"; then
        local cmd
        cmd=$(basename "$wrapper")
        rm "$wrapper"
        echo "  removed $cmd"
      fi
    done
  fi
}

link_skills() {
  local name="$1"
  local repo="$INSTALLED_DIR/$name"
  local target
  target=$(readlink -f "$repo" 2>/dev/null) || die "broken symlink: $name"

  [ -d "$target/skills" ] || return 0

  mkdir -p "$SKILLS_DIR"
  for skill_entry in "$target/skills"/*/; do
    [ -d "$skill_entry" ] || continue
    local skill
    skill=$(basename "$skill_entry")
    local link="$SKILLS_DIR/$skill"

    # Don't overwrite non-symlinks or symlinks pointing elsewhere (local skills)
    if [ -e "$link" ] && ! [ -L "$link" ]; then
      echo "agentenv: warning: $SKILLS_DIR/$skill exists and is not a symlink — skipping"
      continue
    fi
    if [ -L "$link" ]; then
      local existing
      existing=$(readlink "$link")
      if [ "$existing" != "$INSTALLED_DIR/$name/skills/$skill" ]; then
        echo "agentenv: warning: $SKILLS_DIR/$skill → $existing (owned by another repo) — skipping"
        continue
      fi
    fi

    ln -sfn "$INSTALLED_DIR/$name/skills/$skill" "$link"
    echo "  $skill"
  done
}

unlink_skills() {
  local name="$1"
  local repo="$INSTALLED_DIR/$name"
  local target
  target=$(readlink -f "$repo" 2>/dev/null || echo "")

  if [ -n "$target" ] && [ -d "$target/skills" ]; then
    for skill_entry in "$target/skills"/*/; do
      [ -d "$skill_entry" ] || continue
      local skill
      skill=$(basename "$skill_entry")
      local link="$SKILLS_DIR/$skill"
      if [ -L "$link" ] && [ "$(readlink "$link")" = "$INSTALLED_DIR/$name/skills/$skill" ]; then
        rm "$link"
        echo "  removed skill $skill"
      fi
    done
  else
    # Broken symlink — scan skills dir for symlinks pointing into this repo
    [ -d "$SKILLS_DIR" ] || return 0
    for link in "$SKILLS_DIR"/*; do
      [ -L "$link" ] || continue
      if readlink "$link" | grep -qF "$INSTALLED_DIR/$name/"; then
        local skill
        skill=$(basename "$link")
        rm "$link"
        echo "  removed skill $skill"
      fi
    done
  fi
}

# --- Subcommand: install ---
cmd_install() {
  local name="${1:-}"
  # Resolve paths like "." or "./foo" to a proper name
  if [ -z "$name" ] || [ "$name" = "." ]; then
    name=$(basename "$(pwd)")
  else
    name=$(basename "$(cd "$name" 2>/dev/null && pwd || echo "$name")")
  fi
  [ -d "$(pwd)" ] || die "current directory is not valid"
  mkdir -p "$INSTALLED_DIR"
  ln -sfn "$(pwd)" "$INSTALLED_DIR/$name"
  echo "agentenv: installed $name → $(pwd)"
  echo "agentenv: generating wrappers:"
  generate_wrappers "$name"
  echo "agentenv: linking skills:"
  link_skills "$name"
}

# --- Subcommand: uninstall ---
cmd_uninstall() {
  local name="${1:-}"
  [ -n "$name" ] || die "usage: agentenv uninstall <name>"
  [ -L "$INSTALLED_DIR/$name" ] || die "not installed: $name"
  echo "agentenv: removing wrappers:"
  remove_wrappers "$name"
  echo "agentenv: removing skills:"
  unlink_skills "$name"
  rm "$INSTALLED_DIR/$name"
  echo "agentenv: uninstalled $name"
}

# --- Subcommand: list ---
cmd_list() {
  if [ ! -d "$INSTALLED_DIR" ] || [ -z "$(ls -A "$INSTALLED_DIR" 2>/dev/null)" ]; then
    echo "agentenv: no repos installed"
    return
  fi
  for link in "$INSTALLED_DIR"/*; do
    [ -L "$link" ] || continue
    local name
    name=$(basename "$link")
    local target
    target=$(readlink -f "$link" 2>/dev/null || echo "(broken)")
    local has_bin="no"
    local has_flake="no"
    local skills_count=0
    [ -d "$target/bin" ] && has_bin="yes"
    [ -f "$target/flake.nix" ] && has_flake="yes"
    if [ -d "$target/skills" ]; then
      skills_count=$(find "$target/skills" -mindepth 1 -maxdepth 1 \( -type d -o -type l \) 2>/dev/null | wc -l | tr -d ' ')
    fi
    printf "%-20s → %-40s  bin: %-3s  flake: %-3s  skills: %s\n" "$name" "$target" "$has_bin" "$has_flake" "$skills_count"
  done
}

# --- Subcommand: rewrap ---
cmd_rewrap() {
  if [ ! -d "$INSTALLED_DIR" ] || [ -z "$(ls -A "$INSTALLED_DIR" 2>/dev/null)" ]; then
    echo "agentenv: no repos installed"
    return
  fi
  for link in "$INSTALLED_DIR"/*; do
    [ -L "$link" ] || continue
    local name
    name=$(basename "$link")
    echo "agentenv: rewrapping $name:"
    generate_wrappers "$name"
    link_skills "$name"
  done
}

# --- Environment management ---

env_vol_name() { echo "${ENV_VOL_PREFIX}$1"; }

env_vol_exists() {
  container volume list 2>/dev/null | grep -q "^$(env_vol_name "$1") "
}

cmd_env_create() {
  local name="${1:-}"
  [ -n "$name" ] || die "usage: agentenv env create <name> [directory]"
  local src_dir="${2:-}"

  if env_vol_exists "$name"; then
    die "environment already exists: $name (use 'agentenv env rm $name' first)"
  fi

  local vol
  vol=$(env_vol_name "$name")

  echo "agentenv: creating environment '$name'..."
  container volume create "$vol"

  if [ -n "$src_dir" ]; then
    src_dir="$(cd "$src_dir" 2>/dev/null && pwd)" || die "directory not found: $src_dir"

    # Boot a temp container to copy files into the volume
    echo "agentenv: copying $src_dir into environment..."
    container run --rm -v "$vol:/mnt/env" -v "$src_dir:/mnt/src" "$IMAGE" \
      /busybox sh -c '/busybox cp -a /mnt/src/. /mnt/env/'
  fi

  echo "agentenv: environment '$name' created."
}

cmd_env_list() {
  local found=false
  while IFS= read -r line; do
    local vol_name
    vol_name=$(echo "$line" | awk '{print $1}')
    case "$vol_name" in
      ${ENV_VOL_PREFIX}*)
        local env_name="${vol_name#$ENV_VOL_PREFIX}"
        printf "  %s\n" "$env_name"
        found=true
        ;;
    esac
  done < <(container volume list 2>/dev/null)
  if ! $found; then
    echo "agentenv: no environments"
  fi
}

cmd_env_rm() {
  local name="${1:-}"
  [ -n "$name" ] || die "usage: agentenv env rm <name>"
  env_vol_exists "$name" || die "environment not found: $name"

  local vol
  vol=$(env_vol_name "$name")
  container volume rm "$vol"
  echo "agentenv: environment '$name' deleted."
}

cmd_env() {
  local subcmd="${1:-}"
  shift || true
  case "$subcmd" in
    create) cmd_env_create "$@" ;;
    list)   cmd_env_list ;;
    rm)     cmd_env_rm "$@" ;;
    *)      die "usage: agentenv env {create|list|rm}" ;;
  esac
}

# --- Dispatch subcommands ---
case "${1:-}" in
  env)       shift; cmd_env "$@"; exit 0 ;;
  install)   shift; cmd_install "$@"; exit 0 ;;
  uninstall) shift; cmd_uninstall "$@"; exit 0 ;;
  list)      cmd_list; exit 0 ;;
  rewrap)    cmd_rewrap; exit 0 ;;
  -h|--help) usage ;;
esac

# --- Parse arguments ---

while [ $# -gt 0 ]; do
  case "$1" in
    --env)
      [ -n "${2:-}" ] || die "missing argument for --env"
      ENV_NAME="$2"
      shift 2
      ;;
    -p|--profile)
      [ -n "${2:-}" ] || die "missing argument for $1"
      PROFILE_DIR="$2"
      shift 2
      ;;
    --no-profile)
      PROFILE_DIR=""
      shift
      ;;
    -t)
      FORCE_TTY=true
      shift
      ;;
    -h|--help)
      usage
      ;;
    --)
      shift
      CMD_ARGS=("$@")
      break
      ;;
    -*)
      die "unknown option: $1"
      ;;
    *)
      break
      ;;
  esac
done

# --- Resolve target directory and command ---
# If we didn't hit -- yet, the next positional is the directory,
# then look for -- followed by the command.
if [ ${#CMD_ARGS[@]} -eq 0 ]; then
  TARGET_DIR="${1:-.}"
  shift || true
  # Check for -- after directory
  if [ "${1:-}" = "--" ]; then
    shift
    CMD_ARGS=("$@")
  fi
else
  # -- was already consumed during option parsing (before directory)
  # This shouldn't normally happen since directory comes before --
  TARGET_DIR="."
fi

TARGET_DIR="$(cd "$TARGET_DIR" 2>/dev/null && pwd)" || die "directory not found: $TARGET_DIR"
[ -f "$TARGET_DIR/flake.nix" ] || die "no flake.nix in $TARGET_DIR"

# --- Validate environment or profile ---
if [ -n "$ENV_NAME" ]; then
  # --env takes precedence: disable profile
  env_vol_exists "$ENV_NAME" || die "environment not found: $ENV_NAME (create with 'agentenv env create $ENV_NAME')"
  PROFILE_DIR=""
elif [ -n "$PROFILE_DIR" ]; then
  _orig_profile="$PROFILE_DIR"
  PROFILE_DIR="$(cd "$PROFILE_DIR" 2>/dev/null && pwd)" || die "profile directory not found: $_orig_profile"
  [ -f "$PROFILE_DIR/activate.sh" ] || die "no activate.sh in profile directory: $PROFILE_DIR"
fi

# --- Cleanup on exit ---
cleanup() {
  if container volume list 2>/dev/null | grep -q "^${TEMP_VOL} "; then
    container volume rm "$TEMP_VOL" 2>/dev/null || true
  fi
}
trap cleanup EXIT INT TERM

# --- Bootstrap golden volume if needed ---
golden_exists() {
  container volume list 2>/dev/null | grep -q "^${GOLDEN_VOL} "
}

bootstrap_golden() {
  echo "agentenv: bootstrapping golden volume (first-time setup)..."
  container volume create "$GOLDEN_VOL"
  container run --rm -v "$GOLDEN_VOL:/nix" "$IMAGE" /bin/sh -c "echo 'agentenv: seed complete.'"
  echo "agentenv: golden volume ready."
}

if ! golden_exists; then
  bootstrap_golden
fi

# --- Create temp volume + APFS clone ---
container volume create "$TEMP_VOL" >/dev/null
rm "$VOLUMES_DIR/$TEMP_VOL/volume.img"
/bin/cp -c "$VOLUMES_DIR/$GOLDEN_VOL/volume.img" "$VOLUMES_DIR/$TEMP_VOL/volume.img"

# --- Build container run command ---
RUN_ARGS=(--rm -v "$TEMP_VOL:/nix" -v "$TARGET_DIR:/work")

# TTY handling: follow Docker's auto-detection model
if [ ${#CMD_ARGS[@]} -gt 0 ]; then
  # Command given → non-interactive unless -t forces TTY
  if [ "$FORCE_TTY" = true ]; then
    RUN_ARGS+=(-it)
  fi
elif [ -t 0 ]; then
  # No command + stdin is a terminal → interactive
  RUN_ARGS+=(-it)
fi
# Stdin not a terminal + no command → non-interactive (no flags needed)

if [ -n "$ENV_NAME" ]; then
  RUN_ARGS+=(-v "$(env_vol_name "$ENV_NAME"):/root" -e "AGENTENV_ENV=1")
elif [ -n "$PROFILE_DIR" ]; then
  RUN_ARGS+=(-v "$PROFILE_DIR:/root/profile" -e "AGENTENV_PROFILE=/root/profile")
fi

# Mount installed repos (skip duplicates of already-mounted paths)
if [ -d "$INSTALLED_DIR" ]; then
  for link in "$INSTALLED_DIR"/*; do
    [ -L "$link" ] || continue
    name=$(basename "$link")
    target=$(readlink -f "$link")
    [ -d "$target" ] || continue
    # Skip if this path is already mounted as /work or /root/profile
    [ "$target" = "$TARGET_DIR" ] && continue
    [ -n "$PROFILE_DIR" ] && [ "$target" = "$PROFILE_DIR" ] && continue
    RUN_ARGS+=(-v "$target:/installed/$name")
  done
fi

# Run container and capture exit code
EXIT_CODE=0
container run "${RUN_ARGS[@]}" "$IMAGE" "${CMD_ARGS[@]}" || EXIT_CODE=$?

# --- Promote: clone temp back to golden ---
/bin/cp -c "$VOLUMES_DIR/$TEMP_VOL/volume.img" "$VOLUMES_DIR/$GOLDEN_VOL/volume.img"

# cleanup runs via trap
exit "$EXIT_CODE"
